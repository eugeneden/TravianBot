# coding: cp1251import timefrom math import sqrtimport randomfrom datetime import datetime, timedeltafrom multiprocessing import Processfrom configparser import ConfigParserfrom api import TravianApifrom notifier.telegram import Telegramdef printl(*args):    print(datetime.now().strftime('%d.%m.%Y %H:%M:%S'), ' | ', *args)def pause(_min, _max):    time.sleep(random.randint(_min, _max) * 60)def adaptive_pause():    now = datetime.now()    night = (datetime(now.year, now.month, now.day, 0, 0), datetime(now.year, now.month, now.day, 8, 59, 59))    day = (datetime(now.year, now.month, now.day, 9, 0), datetime(now.year, now.month, now.day, 23, 59, 59))    if night[0] < now < night[1]:        sl = random.randint(90, 120)        printl('Следующая проверка через: ', sl, 'мин.')        time.sleep(sl * 60)    elif day[0] < now < day[1]:        sl = random.randint(4, 16)        printl('Следующая проверка через: ', sl, 'мин.')        time.sleep(sl * 60)class TravianBot:    settings = ConfigParser()    settings.read('config/config.ini')    api = TravianApi(        domain=settings.get('connection', 'domain'),        server=settings.get('connection', 'server'),        user=settings.get('connection', 'username'),        password=settings.get('connection', 'password')    )    def __init__(self):        self.telegram = Telegram(self.settings)        self.farm_list = list({            (155, 37), (149, 40), (156, 47), (158, 47), (156, 22), (158, 19), (162, 45)        })        self.farm_list_spam = list({            (154, 23), (158, 31), (160, 20), (161, 34),            (167, 26), (164, 19), (147, 32),            (149, 17), (151, 15), (144, 24), (144, 27),            (153, 19), (162, 35), (170, 25), (170, 23),            (168, 18), (146, 31), (159, 25), (155, 28)        })        self.min_troops_speed = 1 / 257  # fields per second        self.farm_troops = {'Ополченцы': 't1', 'Колесницы Решефа': 't6',                            'Стражники Анхура': 't5', 'Воины с хопешем': 't3'}    def _get_distance(self, coords_1, coords_2):        return round(sqrt((coords_1[0] - coords_2[0])**2 + (coords_1[1] - coords_2[1])**2), 1)    def get_attacks(self):        movs = self.api.get_movements()        if movs['income']:            for m in movs['income']:                if 'ападени' in m:                    return m + ': ' + movs['income'][m]        return ''    def _shake_list(self, l):        list_length = len(l)        for i in range(list_length):            random_index = random.randint(0, list_length - 1)            l[i], l[random_index] = l[random_index], l[i]        return l    def _farm(self, available_troops, farm_list):        _t = []        for coords in self._shake_list(farm_list):            _a = {}            for t in available_troops:                n = int(available_troops[t]) // len(farm_list)                _a[t] = n            distance = self._get_distance(self.main_village, coords)            troops_time = round(distance * 181)            if not self.api.send_attack(coords, **_a):                printl(coords, 'отправлено: %s' % _a)                _t.append(troops_time)            else:                printl('Ошибка при отправке набега на деревню {}.'.format(coords))            time.sleep(random.randint(4, 9))        return max(_t)    def run(self):        # incoming_attacks = ''        #        stable_id = 38        barracks_id = 32        #        # _not_attack_once = 1        #        reshef = 0  # t6        ash = 0  # t2        # anhur = 0  # t5        # soldu = 0  # t4        # start_farm = 1        #        # prev = datetime.now() - timedelta(hours=2)        # prev_interval = 3600 + random.randint()        while True:            try:                # printl('Проверка входящих атак...')                # try:                #     incoming_attacks = self.get_attacks()                # except:                #     pass                #                # if incoming_attacks:                #     printl(incoming_attacks)                #     self.telegram.send(incoming_attacks)                #     printl('Оповещение об атаках было отправлено в Telegram.')                # time.sleep(3)                #                # start troops training                printl('Проверка доступных юнитов...')                available_units = self.api.show_available_units(barracks_id)                for i in available_units:                    if i[0] == 'Шпион Сопду':                        soldu = i[1]                    elif i[0] == 'Стражник Анхура':                        anhur = i[1]                    elif i[0] == 'Служитель Аш':                        ash = i[1]                    else:                        reshef = i[1]                printl('Доступно: {} Служителей Аш для тренировки.'.format(ash))                ash = int(ash) - 100 if int(ash) > 100 else int(ash)                if int(ash) > 0:                    self.api.create_units(solar_id=barracks_id, t2=ash)                    printl('Тренировка {} Служителей Аш запущена.'.format(ash))                #                # time.sleep(3)                # start farming                # if _not_attack_once:                #     if datetime.now() >= prev + timedelta(seconds=prev_interval):                #         try:                #             actual_troops = self.api.get_actual_units()                #                #             _tff = {}                #             troops_for_farm = {self.farm_troops.get(k, k): v for k, v in actual_troops.items()}                #                #             for k, v in self.farm_troops.items():                #                 if troops_for_farm.get(v):                #                     _tff[v] = troops_for_farm[v]                #                #             prev = datetime.now()                #                #             if (int(_tff.get('t6', 0)) / len(self.farm_list)) >= 50:                #                 prev_interval = self._farm({'t5': _tff.get('t5', 0), 't6': _tff.get('t6', 0)}, self.farm_list) * 2                #             # max_troops_time_spam = self.farm({'t1': _tff.get('t1', 0), 't3': _tff.get('t3', 0)}, self.farm_list_spam)                #                #             # prev_interval = max_troops_time_spam if max_troops_time_spam > max_troops_time else max_troops_time                #                #         except:                #             pass                #                # _not_attack_once = 1                # next_check = (prev_interval // 60) * 2 if (prev_interval // 60) * 2 <= 120 else 120                #                # next_check = random.randint(56, 63)                # printl('Следующая проверка через %d минут.' % (prev_interval // 60))                # next_check_seconds = prev_interval                # time.sleep(next_check_seconds)                adaptive_pause()            except KeyboardInterrupt:                exit(0)            except:                time.sleep(300)                self.api.login()if __name__ == '__main__':    bot = TravianBot()    bot.api.set_village(9554)    bot.run()